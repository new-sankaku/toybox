# 原則: 技術品質

## 概要
ゲームの技術的実装の品質・パフォーマンス・保守性を確保するための原則。
アーキテクチャ設計、コード品質、パフォーマンス最適化、テスト戦略を対象とする。

## 核心原則

### 原則1: アーキテクチャの適切性
ゲームの規模と要件に適した技術構成を選択し、過剰設計を避けること。
将来の拡張が想定される箇所のみ拡張可能に設計し、それ以外はシンプルに保つ。

- 良い例: 小規模2Dゲームにシンプルなシーン管理、大規模ゲームにECSアーキテクチャ
- 悪い例: 小規模ゲームにマイクロサービスアーキテクチャを適用

### 原則2: パフォーマンス要件の明確化
ターゲットプラットフォームのスペックを踏まえた具体的な性能目標を設定する。
フレームレート、メモリ使用量、ロード時間の上限を定義し、継続的に計測する。

- 良い例: 「60fps維持、メモリ256MB以内、初期ロード3秒以内」と定量的に定義
- 悪い例: 「快適に動く」程度の曖昧な目標

### 原則3: コード品質と可読性
名前付け・構造・エラー処理の一貫した規約を設け、チーム全体で遵守する。
コードは「動く」だけでなく「読める」「変更できる」品質であること。

- 良い例: 機能ごとに明確に分離されたモジュール、意図が伝わる命名
- 悪い例: 一つの関数に複数の責務、略語だらけの変数名

### 原則4: テスト戦略の設計
ゲームの特性に応じたテスト戦略を設計し、自動化可能な部分を最大化する。
ゲームロジック（決定的処理）とゲームプレイ（非決定的体験）を分けて考える。

- 良い例: コアメカニクスのユニットテスト + 統合テスト + プレイテストの三層構造
- 悪い例: テスト戦略がなく、手動テストのみに依存

### 原則5: エラーハンドリングと堅牢性
予期しない状態からの回復機能を設計し、クラッシュを最小限に抑える。
エラーの種類に応じた適切な対応（リトライ、フォールバック、ユーザー通知）を定義する。

- 良い例: セーブデータ破損時の自動バックアップ復元、ネットワーク切断時のオフラインモード
- 悪い例: 未処理例外でクラッシュし、進行データが失われる

## 適用パターン

### パターンA: 技術仕様策定時
ターゲットプラットフォーム→性能要件→アーキテクチャ選択→技術スタックの順で決定する。

### パターンB: コード実装時
規約に従い、各モジュールが単一責任を持つよう設計。ゲームロジックとプレゼンテーションを分離する。

### パターンC: テスト設計時
テストピラミッド（多数のユニットテスト、適度な統合テスト、少数のE2Eテスト）に従い設計する。

## 評価ルーブリック

| 観点 | 1 (不合格) | 3 (合格) | 5 (優秀) |
|------|-----------|----------|----------|
| アーキテクチャ | 規模に不適切 | 要件に適した構成 | 拡張性と簡潔さが高度に両立 |
| パフォーマンス | 目標未定義・未達 | 定量目標があり達成 | 最適化が行き届き余裕がある |
| コード品質 | 規約なし・一貫性なし | 規約があり遵守されている | 高い可読性と変更容易性 |
| テスト戦略 | テストなし | テスト戦略がある | 三層テスト+自動化が実現 |
| 堅牢性 | エラーで容易にクラッシュ | 基本的なエラー処理がある | 異常系からの優雅な回復が設計されている |
